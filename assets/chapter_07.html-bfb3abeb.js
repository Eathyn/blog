const e=JSON.parse(`{"key":"v-2be0e98c","path":"/front_end/typescript/book-learning_typescript/chapter_07.html","title":"Interfaces","lang":"zh-CN","frontmatter":{"date":"2022-11-29T00:00:00.000Z","category":"TypeScript","tag":["Book - Learning TypeScript","chapter 07"],"description":"Interfaces Interfaces are in many ways similar to aliased object types but are generally preferred for their more readable error messages, speedier compiler performance, and better interoperability with classes. Type Aliases Versus Interfaces interfaces can “merge” together to be augmented — a feature particularly useful when working with third-party code such as built-in globals or npm packages. interfaces can be used to type check the structure of class declarations while type aliases cannot. interfaces are generally speedier for the TypeScript type checker to work with. interfaces' error messages are more likely to be readable in hard edge cases. TypeScript developers who prefer semicolons generally put them after type aliases and not after interfaces.","head":[["meta",{"property":"og:url","content":"https://eathyn.github.io/blog/blog/front_end/typescript/book-learning_typescript/chapter_07.html"}],["meta",{"property":"og:title","content":"Interfaces"}],["meta",{"property":"og:description","content":"Interfaces Interfaces are in many ways similar to aliased object types but are generally preferred for their more readable error messages, speedier compiler performance, and better interoperability with classes. Type Aliases Versus Interfaces interfaces can “merge” together to be augmented — a feature particularly useful when working with third-party code such as built-in globals or npm packages. interfaces can be used to type check the structure of class declarations while type aliases cannot. interfaces are generally speedier for the TypeScript type checker to work with. interfaces' error messages are more likely to be readable in hard edge cases. TypeScript developers who prefer semicolons generally put them after type aliases and not after interfaces."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-12T13:42:19.000Z"}],["meta",{"property":"article:tag","content":"Book - Learning TypeScript"}],["meta",{"property":"article:tag","content":"chapter 07"}],["meta",{"property":"article:published_time","content":"2022-11-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-12T13:42:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Interfaces\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-11-29T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-12T13:42:19.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Type Aliases Versus Interfaces","slug":"type-aliases-versus-interfaces","link":"#type-aliases-versus-interfaces","children":[]},{"level":2,"title":"Types of Properties","slug":"types-of-properties","link":"#types-of-properties","children":[{"level":3,"title":"Optional Properties","slug":"optional-properties","link":"#optional-properties","children":[]},{"level":3,"title":"Read-Only Properties","slug":"read-only-properties","link":"#read-only-properties","children":[]},{"level":3,"title":"Functions and Methods","slug":"functions-and-methods","link":"#functions-and-methods","children":[]},{"level":3,"title":"Call Signature","slug":"call-signature","link":"#call-signature","children":[]},{"level":3,"title":"Index Signature","slug":"index-signature","link":"#index-signature","children":[]},{"level":3,"title":"Nested Interfaces","slug":"nested-interfaces","link":"#nested-interfaces","children":[]}]},{"level":2,"title":"Interface Extensions","slug":"interface-extensions","link":"#interface-extensions","children":[{"level":3,"title":"Overridden Properties","slug":"overridden-properties","link":"#overridden-properties","children":[]},{"level":3,"title":"Extending Multiple Interfaces","slug":"extending-multiple-interfaces","link":"#extending-multiple-interfaces","children":[]}]},{"level":2,"title":"Interface Merging","slug":"interface-merging","link":"#interface-merging","children":[{"level":3,"title":"Member Naming Conflicts","slug":"member-naming-conflicts","link":"#member-naming-conflicts","children":[]}]}],"git":{"createdTime":1681306939000,"updatedTime":1681306939000,"contributors":[{"name":"Eathyn","email":"eathynzakas@gmail.com","commits":1}]},"readingTime":{"minutes":3.18,"words":954},"filePathRelative":"front_end/typescript/book-learning_typescript/chapter_07.md","localizedDate":"2022年11月29日","excerpt":"<h1> Interfaces</h1>\\n<ul>\\n<li>Interfaces are in many ways similar to aliased object types but are generally preferred for their more readable error messages, speedier compiler performance, and better interoperability with classes.</li>\\n</ul>\\n<h2> Type Aliases Versus Interfaces</h2>\\n<ul>\\n<li>\\n<p>interfaces can “merge” together to be augmented — a feature particularly useful when working with third-party code such as built-in globals or npm packages.</p>\\n</li>\\n<li>\\n<p>interfaces can be used to type check the structure of class declarations while type aliases cannot.</p>\\n</li>\\n<li>\\n<p>interfaces are generally speedier for the TypeScript type checker to work with.</p>\\n</li>\\n<li>\\n<p>interfaces' error messages are more likely to be readable in hard edge cases.</p>\\n</li>\\n<li>\\n<p>TypeScript developers who prefer semicolons generally put them after type aliases and not after interfaces.</p>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
