import{_ as r,W as o,X as t,Y as e,Z as a,$ as c,a0 as s,C as n}from"./framework-0d71bc9d.js";const d="/blog/assets/graph-merge-5532f7c7.png",l="/blog/assets/graph-rebase-b6d5aae6.png",g="/blog/assets/basic-before-rebase-3572ad23.png",b="/blog/assets/basic-after-rebase-00f99825.png",p="/blog/assets/basic-merge-after-rebase-6571fee3.png",h="/blog/assets/before-rebase-ca069ad9.png",m="/blog/assets/rebase-client-branch-df7e0c72.png",f="/blog/assets/rebase-server-branch-5df84939.png",u="/blog/assets/the-perils-of-rebasing-d6ff27e1.png",_={},x=e("h1",{id:"rebase",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#rebase","aria-hidden":"true"},"#"),a(" Rebase")],-1),k=e("h2",{id:"作用",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#作用","aria-hidden":"true"},"#"),a(" 作用")],-1),v={href:"https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase#:~:text=The%20primary%20reason%20for%20rebasing%20is%20to%20maintain%20a%20linear%20project%20history.",target:"_blank",rel:"noopener noreferrer"},y=s('<ul><li><p><code>merge</code> 和 <code>rebase</code> 的作用相同，都是为了将一个分支上的 commit 整合到另一个分支上。</p></li><li><p><code>rebase</code> 与 <code>merge</code> 的区别在于 <code>rebase</code> 的提交历史是一条直线，而 <code>merge</code> 则包含多条分支：</p></li></ul><figure><img src="'+d+'" alt="merge 的图像" tabindex="0" loading="lazy"><figcaption>merge 的图像</figcaption></figure><figure><img src="'+l+'" alt="rebase 的图像" tabindex="0" loading="lazy"><figcaption>rebase 的图像</figcaption></figure><h2 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法" aria-hidden="true">#</a> 基本用法</h2><blockquote><p>Reference: Pro Git: p92-94</p></blockquote><p>执行 rebase 之前的 main 分支和 extra 分支状态如下图所示。现在要把 extra 上的 commit 整合到 main 分支。</p><figure><img src="'+g+'" alt="执行 rebase 之前" tabindex="0" loading="lazy"><figcaption>执行 rebase 之前</figcaption></figure><h3 id="方式一" tabindex="-1"><a class="header-anchor" href="#方式一" aria-hidden="true">#</a> 方式一</h3><ul><li>执行 <code>git rebase main extra</code> 命令后变成了单线结构，并且 <code>v3</code> 的哈希值发生了改变。</li></ul><figure><img src="'+b+'" alt="执行 rebase 之后" tabindex="0" loading="lazy"><figcaption>执行 rebase 之后</figcaption></figure><ul><li>main 分支合并 extra 分支。</li></ul><figure><img src="'+p+'" alt="rebase 之后合并分支" tabindex="0" loading="lazy"><figcaption>rebase 之后合并分支</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>git rebase &lt;base-branch&gt; &lt;topic-branch&gt;</code>：把 topic-branch 上的 commit 整合到 base-branch。这个命令在任何分支上都可以执行，不需要切换分支。</p></div><h3 id="方式二" tabindex="-1"><a class="header-anchor" href="#方式二" aria-hidden="true">#</a> 方式二</h3><ul><li>切换到 extra 分支，执行 <code>git rebase main</code>。</li><li>main 分支合并 extra 分支。</li></ul><h2 id="整合到任意分支" tabindex="-1"><a class="header-anchor" href="#整合到任意分支" aria-hidden="true">#</a> 整合到任意分支</h2><blockquote><p>Reference: Pro Git: p94-p97</p></blockquote><ul><li><p><code>rebase</code> 可以将一个分支上的 commit 整合到任意分支上。</p></li><li><p><code>client</code> 分支可以把不属于父分支（<code>server</code>）的 commit（<code>C8</code>、<code>C9</code>）整合到 <code>master</code> 分支；<code>server</code> 分支可以把不属于父分支（<code>master</code>）的 commit <code>C3</code>、<code>C4</code>、<code>C10</code> 整合到 <code>master</code> 分支。</p></li></ul><figure><img src="'+h+'" alt="使用 rebase 之前各分支的状态" tabindex="0" loading="lazy"><figcaption>使用 rebase 之前各分支的状态</figcaption></figure><ul><li><code>git rebase --onto master server client</code> 表示把 <code>client</code> 分支上不属于 <code>server</code> 分支的 commit 整合到 <code>master</code>。</li></ul><figure><img src="'+m+'" alt="整合 clint 分支的 commit" tabindex="0" loading="lazy"><figcaption>整合 clint 分支的 commit</figcaption></figure><ul><li><code>git rebase master server</code> 表示把 <code>server</code> 分支上不属于 <code>master</code> 分支的 commit 整合到 <code>master</code>。</li></ul><figure><img src="'+f+'" alt="整合 server 分支的 commit" tabindex="0" loading="lazy"><figcaption>整合 server 分支的 commit</figcaption></figure><h2 id="风险和解决方法" tabindex="-1"><a class="header-anchor" href="#风险和解决方法" aria-hidden="true">#</a> 风险和解决方法</h2><h3 id="风险" tabindex="-1"><a class="header-anchor" href="#风险" aria-hidden="true">#</a> 风险</h3><blockquote><p>Reference: Pro Git: p97-99</p></blockquote><ul><li>使用 rebase 的风险：如果你 rebase 一些之前已经提交到远程仓库的 commit，并且别人基于这个 commit 在开发，那么会导致别人在拉取代码的时候发现有重复的提交，如下图所示：</li></ul><figure><img src="'+u+'" alt="C4 为重复的提交" tabindex="0" loading="lazy"><figcaption>C4 为重复的提交</figcaption></figure><h3 id="解决方法一" tabindex="-1"><a class="header-anchor" href="#解决方法一" aria-hidden="true">#</a> 解决方法一</h3><blockquote><p>Reference: Pro Git: p99-100</p></blockquote><ul><li>git pull <mark>--rebase</mark> <code>&lt;repo-shortname&gt;</code> <code>&lt;repo-url&gt;</code></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>配置 <code>git config pull.rebase true</code> 可以让执行 git pull 时默认带 <code>--rebase</code> 参数。</p></div><h3 id="解决方法二" tabindex="-1"><a class="header-anchor" href="#解决方法二" aria-hidden="true">#</a> 解决方法二</h3><blockquote><p>Reference: Pro Git: p99-100</p></blockquote><ul><li><code>git fetch</code></li><li><code>git rebase &lt;base-branch&gt; &lt;topic-branch&gt;</code></li></ul>',35);function q(z,C){const i=n("ExternalLinkIcon");return o(),t("div",null,[x,k,e("blockquote",null,[e("p",null,[a("Reference: "),e("a",v,[a("the primary reason for rebasing"),c(i)])])]),y])}const G=r(_,[["render",q],["__file","index.html.vue"]]);export{G as default};
