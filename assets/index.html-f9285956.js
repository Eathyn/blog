import{_ as e,W as t,X as o,Y as n,Z as s,$ as p,a0 as c,C as l}from"./framework-c8ebc670.js";const i="/blog/assets/selection_sort-0d0c0efa.gif",r={},u=c('<h1 id="selection-sort" tabindex="-1"><a class="header-anchor" href="#selection-sort" aria-hidden="true">#</a> Selection Sort</h1><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><blockquote><p>reference: <em>A Common-Sense Guide to DSA</em>: p63-p71</p></blockquote><p>从左到右进行遍历，获取最小值后与最开始进行遍历的地方交换值。</p><figure><img src="'+i+`" alt="4,2,7,1,3" tabindex="0" loading="lazy"><figcaption>4,2,7,1,3</figcaption></figure><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><blockquote><p>reference: <em>A Common-Sense Guide to DSA</em>: p63-p71</p></blockquote><ul><li><code>i &lt; arr.length - 1</code>：最后一项不需要排序</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// \`i &lt; arr.length - 1\`：最后一项不需要排序</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// \`lowestNumberIndex\`：每次最开始遍历的地方的索引</span>
    <span class="token keyword">let</span> lowestNumberIndex <span class="token operator">=</span> i
    <span class="token comment">// 找出最小项的索引值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>lowestNumberIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lowestNumberIndex <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果最小项的索引值是每次最开始遍历的地方的索引，则不需要交换</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lowestNumberIndex <span class="token operator">!==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>lowestNumberIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>lowestNumberIndex<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a> 时间复杂度</h2>`,10),d={href:"https://en.wikipedia.org/wiki/Selection_sort#Complexity",target:"_blank",rel:"noopener noreferrer"},k=n("ul",null,[n("li",null,[s("输入："),n("code",null,"[4, 2, 7, 1, 3]"),n("ul",null,[n("li",null,"第一轮：比较 4 次，即 n - 1 次"),n("li",null,"第二轮：比较 3 次，即 n - 2 次"),n("li",null,"第三轮：比较 2 次，即 n - 3 次"),n("li",null,"第四轮：比较 1 次，即 n - 4 次")])])],-1),m=n("p",null,"$$ \\begin{aligned} 执行比较的总次数 &= (n - 1) + (n - 2) + ... + 2 + 1 \\ &= ((n - 1) + 1) \\times \\frac{n - 1}{2} \\ &= n \\times \\frac{n - 1}{2} \\ &= \\frac{n ^ 2 - n}{2} \\ &= \\frac{1}{2}n^2 - \\frac{1}{2}n \\ \\end{aligned} $$",-1),v=n("ul",null,[n("li",null,"因为最好的情况（升序）和最坏的情况（降序）都执行相同次数的比较操作，所以算法复杂度都为 O($n^2$)。")],-1);function b(h,f){const a=l("ExternalLinkIcon");return t(),o("div",null,[u,n("blockquote",null,[n("p",null,[s("reference: "),n("a",d,[s("selection sort in wikipedia"),p(a)])])]),k,m,v])}const x=e(r,[["render",b],["__file","index.html.vue"]]);export{x as default};
