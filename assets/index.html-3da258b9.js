const e=JSON.parse('{"key":"v-3786cb64","path":"/cs/dsa/linear_structure/linked_list/single_linked_list/","title":"Linked List","lang":"zh-CN","frontmatter":{"date":"2023-03-04T00:00:00.000Z","category":"DSA","tag":["linked list","single linked list"],"description":"Linked List 链表相对于数组的优点 内存不需要成块分配，可以分散在各个地方。 插入或删除非末尾的元素不需要移动其他元素的位置。 队列使用双向列表实现效率更高，因为双向链表的首位元素和末尾元素的插入或删除操作的时间复杂度都是 O(1)。 链表与数组的时间复杂度对比 Reading worst case array: O(1) linked list: O(n) 链表末尾 best case array: O(1) linked list: O(1) 链表开头","head":[["meta",{"property":"og:url","content":"https://eathyn.github.io/blog/blog/cs/dsa/linear_structure/linked_list/single_linked_list/"}],["meta",{"property":"og:title","content":"Linked List"}],["meta",{"property":"og:description","content":"Linked List 链表相对于数组的优点 内存不需要成块分配，可以分散在各个地方。 插入或删除非末尾的元素不需要移动其他元素的位置。 队列使用双向列表实现效率更高，因为双向链表的首位元素和末尾元素的插入或删除操作的时间复杂度都是 O(1)。 链表与数组的时间复杂度对比 Reading worst case array: O(1) linked list: O(n) 链表末尾 best case array: O(1) linked list: O(1) 链表开头"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-12T13:42:19.000Z"}],["meta",{"property":"article:tag","content":"linked list"}],["meta",{"property":"article:tag","content":"single linked list"}],["meta",{"property":"article:published_time","content":"2023-03-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-12T13:42:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linked List\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-04T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-12T13:42:19.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"链表相对于数组的优点","slug":"链表相对于数组的优点","link":"#链表相对于数组的优点","children":[]},{"level":2,"title":"链表与数组的时间复杂度对比","slug":"链表与数组的时间复杂度对比","link":"#链表与数组的时间复杂度对比","children":[{"level":3,"title":"Reading","slug":"reading","link":"#reading","children":[]},{"level":3,"title":"Searching","slug":"searching","link":"#searching","children":[]},{"level":3,"title":"Insertion","slug":"insertion","link":"#insertion","children":[]},{"level":3,"title":"Deletion","slug":"deletion","link":"#deletion","children":[]}]},{"level":2,"title":"应用","slug":"应用","link":"#应用","children":[]},{"level":2,"title":"Refs","slug":"refs","link":"#refs","children":[]}],"git":{"createdTime":1681306939000,"updatedTime":1681306939000,"contributors":[{"name":"Eathyn","email":"eathynzakas@gmail.com","commits":1}]},"readingTime":{"minutes":0.95,"words":286},"filePathRelative":"cs/dsa/linear_structure/linked_list/single_linked_list/index.md","localizedDate":"2023年3月4日","excerpt":"<h1> Linked List</h1>\\n<h2> 链表相对于数组的优点</h2>\\n<ul>\\n<li>内存不需要成块分配，可以分散在各个地方。</li>\\n<li>插入或删除非末尾的元素不需要移动其他元素的位置。</li>\\n<li>队列使用双向列表实现效率更高，因为双向链表的首位元素和末尾元素的插入或删除操作的时间复杂度都是 O(1)。</li>\\n</ul>\\n<h2> 链表与数组的时间复杂度对比</h2>\\n<h3> Reading</h3>\\n<ul>\\n<li>worst case\\n<ul>\\n<li>array: O(1)</li>\\n<li>linked list: O(n) 链表末尾</li>\\n</ul>\\n</li>\\n<li>best case\\n<ul>\\n<li>array: O(1)</li>\\n<li>linked list: O(1) 链表开头</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
