const e=JSON.parse('{"key":"v-14b8b2c1","path":"/front_end/typescript/book-learning_typescript/chapter_11.html","title":"Declaration Files","lang":"zh-CN","frontmatter":{"date":"2023-01-04T00:00:00.000Z","category":"TypeScript","tag":["Book - Learning TypeScript","chapter 11"],"description":"Declaration Files TypeScript projects need a way to be told the type shapes of environment-specific features such as global variables and APIs. A project running in, say, Node.js might have access to built-in Node modules not available in browsers—and vice versa. TypeScript allows declaring type shapes separately from their implementation. Type declarations are typically written in files whose names end with the .d.ts extension, known as declaration files.","head":[["meta",{"property":"og:url","content":"https://eathyn.github.io/blog/blog/front_end/typescript/book-learning_typescript/chapter_11.html"}],["meta",{"property":"og:title","content":"Declaration Files"}],["meta",{"property":"og:description","content":"Declaration Files TypeScript projects need a way to be told the type shapes of environment-specific features such as global variables and APIs. A project running in, say, Node.js might have access to built-in Node modules not available in browsers—and vice versa. TypeScript allows declaring type shapes separately from their implementation. Type declarations are typically written in files whose names end with the .d.ts extension, known as declaration files."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://eathyn.github.io/blog/blog/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-12T13:42:19.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Declaration Files"}],["meta",{"property":"article:tag","content":"Book - Learning TypeScript"}],["meta",{"property":"article:tag","content":"chapter 11"}],["meta",{"property":"article:published_time","content":"2023-01-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-12T13:42:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Declaration Files\\",\\"image\\":[\\"https://eathyn.github.io/blog/blog/\\"],\\"datePublished\\":\\"2023-01-04T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-12T13:42:19.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Declaration Files","slug":"declaration-files-1","link":"#declaration-files-1","children":[]},{"level":2,"title":"Declaring Runtime Values","slug":"declaring-runtime-values","link":"#declaring-runtime-values","children":[{"level":3,"title":"Global Values","slug":"global-values","link":"#global-values","children":[]},{"level":3,"title":"Global Interface Merging","slug":"global-interface-merging","link":"#global-interface-merging","children":[]}]},{"level":2,"title":"Built-In Declarations","slug":"built-in-declarations","link":"#built-in-declarations","children":[{"level":3,"title":"Library Declarations","slug":"library-declarations","link":"#library-declarations","children":[{"level":4,"title":"Library targets","slug":"library-targets","link":"#library-targets","children":[]}]},{"level":3,"title":"DOM Declarations","slug":"dom-declarations","link":"#dom-declarations","children":[]}]},{"level":2,"title":"Module Declarations","slug":"module-declarations","link":"#module-declarations","children":[{"level":3,"title":"Wildcard Module Declarations","slug":"wildcard-module-declarations","link":"#wildcard-module-declarations","children":[]}]},{"level":2,"title":"Package Types","slug":"package-types","link":"#package-types","children":[{"level":3,"title":"declaration","slug":"declaration","link":"#declaration","children":[]},{"level":3,"title":"Dependency Package Types","slug":"dependency-package-types","link":"#dependency-package-types","children":[]},{"level":3,"title":"Exposing Package Types","slug":"exposing-package-types","link":"#exposing-package-types","children":[]}]},{"level":2,"title":"DefinitelyTyped","slug":"definitelytyped","link":"#definitelytyped","children":[{"level":3,"title":"Type Availability","slug":"type-availability","link":"#type-availability","children":[]}]},{"level":2,"title":"Refs","slug":"refs","link":"#refs","children":[]}],"git":{"createdTime":1681306939000,"updatedTime":1681306939000,"contributors":[{"name":"Eathyn","email":"eathynzakas@gmail.com","commits":1}]},"readingTime":{"minutes":3.85,"words":1155},"filePathRelative":"front_end/typescript/book-learning_typescript/chapter_11.md","localizedDate":"2023年1月4日","excerpt":"<h1> Declaration Files</h1>\\n<ul>\\n<li>TypeScript projects need a way to be told the type shapes of environment-specific features such as global variables and APIs. A project running in, say, Node.js might have access to built-in Node modules not available in browsers—and vice versa.</li>\\n<li>TypeScript allows declaring type shapes separately from their implementation.</li>\\n<li>Type declarations are typically written in files whose names end with the <code>.d.ts</code> extension, known as declaration files.</li>\\n</ul>","autoDesc":true}');export{e as data};
